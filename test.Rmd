---
title: "OpenTripPlanner Test"
output: html_notebook
---

```{r}
library(opentripplanner)
library(tmap)
library(dplyr)
otpcon <- otp_connect(hostname="localhost", router="auckland", port=8080)
```

```{r}
routes <- otp_plan(otpcon, fromPlace = c(174.71354, -36.88028), toPlace = c(174.73435, -36.88366), mode=c("TRANSIT", "WALK"), date_time=Sys.time()) # lon lat pairs
tmap_mode("view")          # Set tmap to interactive viewing
qtm(sf::st_zm(routes), lines.col = 'red')      # Plot the route on a map
```

```{r}
queryTime = Sys.time()
routes <- otp_plan(otpcon, fromPlace = c(174.71354, -36.88028), toPlace = c(174.73435, -36.88366), mode=c("TRANSIT", "WALK"), get_geometry=FALSE, date_time=queryTime) # lon lat pairs
#routes_matrix = tidyr::pivot_wider(routes, names_from="route_option", values_from="duration")
etaMinutes = as.numeric(min(difftime(routes$endTime, rep(queryTime, length(routes$endTime)))))
```

```{r}
# map data using sp
#nz = getData('GADM', country="NZ", level=1)
#auckland = nz[nz$NAME_1=="Auckland",]
#plot(auckland)

#alternatively using sf and qtm
nz = st_as_sf(getData('GADM', country="NZ", level=1))
auckland = nz[nz$NAME_1=="Auckland",]
qtm(auckland)

```

```{r}
# make O-D grid
grid = auckland %>% st_make_grid(cellsize=0.01, what='centers') %>% st_intersection(auckland)
st_write(grid, "./grid-1e-2.shp")
```

```{r}
grid = st_read("./grid-1e-2.shp")
```


```{r}
# create an envelope around the bounds
bbox = st_bbox(route)
route_bounds = st_sfc(st_polygon(list(rbind(c(bbox$xmin, bbox$ymin), c(bbox$xmin, bbox$ymax), c(bbox$xmax, bbox$ymax), c(bbox$xmax, bbox$ymin), c(bbox$xmin, bbox$ymin)))))
route_bounds = st_set_crs(route_bounds_sfc, st_crs(route)$input)
```

```{r}
# create a bounding box around a point and create a grid of sample points
centerx = 174.71334
centery = -36.88055
dimx = 0.05
dimy = 0.025
xmin = centerx - 0.5 * dimx
xmax = centerx + 0.5 * dimx
ymin = centery - 0.5 * dimy
ymax = centery + 0.5 * dimy
bounds = st_sfc(st_polygon(list(rbind(c(xmin, ymin), c(xmin, ymax), c(xmax, ymax), c(xmax, ymin), c(xmin, ymin)))))
bounds = st_set_crs(bounds, st_crs(grid)$input)
grid = st_make_grid(bounds, cellsize=0.01, what = "centers")
#qtm(bounds, fill=NULL)
# intersect with region bounds (expensive)
#grid = st_intersection(grid, auckland)
qtm(grid)
```

```{r}
# plan trips between each location in the grid
queryTime = Sys.time()

locations = do.call(rbind, st_geometry(grid))
location_idx = seq(nrow(locations))
location_ids = cbind(as.character(location_idx))

toPlace   = locations[rep(seq(1, nrow(locations)), times = nrow(locations)),]
fromPlace = locations[rep(seq(1, nrow(locations)), each  = nrow(locations)),]

toID = location_ids[rep(seq(1, nrow(location_ids)), times = nrow(location_ids)),]
fromID = location_ids[rep(seq(1, nrow(location_ids)), each  = nrow(location_ids)),]

eta = function(x){
  t = unlist(x, use.names = FALSE)
  dt = as.numeric(difftime(as.POSIXct(t, origin="1970-01-01"), rep(queryTime, length(t))))
  return(min(dt))
}

routes = otp_plan(otpcon, fromPlace=fromPlace, toPlace=toPlace, mode=c("TRANSIT", "WALK"), fromID=fromID, toID=toID,
                  date_time=queryTime, get_geometry=FALSE, ncores=4)
routes_fltr = routes[, c("fromPlace", "toPlace", "endTime")]
routes_matrix = tidyr::pivot_wider(routes_fltr, names_from = "toPlace", values_from = "endTime", values_fn=list(endTime=eta))
# otp_plan will return NA for self-self routes, replace these with 0
routes_matrix[is.na(routes_matrix)] = 0

# add location ids to the grid
grid = st_sf(geoid=as.character(location_idx), geometry=grid)
```

```{r}
# plot one of the resulting point sets
query = 2 # all points will show eta to this toPlace id
eta_grid = left_join(grid, routes_matrix[, c(1, query)], by = c(geoid = "fromPlace"))
eta_grid = rename(eta_grid, eta = query)
eta_valid = eta_grid %>% filter(eta > -1)
qtm(eta_valid, dots.col = "eta")
```

```{r}
#debug routes
origin = 2
dest = 11

routes <- otp_plan(otpcon, fromPlace = locations[origin,], toPlace = locations[dest,], mode=c("TRANSIT", "WALK"))
tmap_mode("view")          # Set tmap to interactive viewing
qtm(eta_valid, dots.col = "eta") + qtm(sf::st_zm(routes))      # Plot the route on a map
```

```{r}
# Mismatch between route times and Sys.time()
```


